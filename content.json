[{"title":"Electron + Vue开发跨平台桌面应用","date":"2021-07-29T06:05:17.000Z","path":"2021/07/29/electron-vue开发跨平台桌面应用/","text":"ElectronElectron是一个使用JavaScript、HTML和CSS构建桌面应用程序的框架。通过将Chromium和Node.js嵌入其二进制文件，Electron允许您维护一个JavaScript代码库，并创建在Windows、macOS和Linux上工作的跨平台应用程序—无需本地开发经验。Electron 官网 Electron + Vue在使用 Electron 进行开发之前，需要安装 Node.js。 安装之后可以在终端输入以下命令检查是否正确安装： 123node -vv14.17.0 创建 Vue 项目我们直接使用脚手架工具 vue-cli 1234567vue create myprojectVue CLI v4.5.13? Please pick a preset: (Use arrow keys)&gt; Default ([Vue 2] babel, eslint) Default (Vue 3) ([Vue 3] babel, eslint) Manually select features 这里我们直接选择 Default ([Vue 2] babel, eslint)，如果有需要可以选择其他选项进行自定义。 自动安装 Electron使用 vue-cli 自动安装 electron，网络原因有可能会不成功，可选择手动安装。 12cd myprojectvue add electron-builder 然后会让你选择什么版本的 Electron，这里我们直接选择最新的版本。 1234? Choose Electron Version (Use arrow keys) ^11.0.0 ^12.0.0&gt; ^13.0.0 下图表示安装成功： 安装完成后，查看项目的目录结构，会发现自动在 src 目录下生成了 backgroug.js 并修改了 package.json。 手动安装 Electron修改package.json，添加以下几行 1234567891011\"scripts\": &#123; \"electron:build\": \"vue-cli-service electron:build\", \"electron:serve\": \"vue-cli-service electron:serve\", \"postinstall\": \"electron-builder install-app-deps\", \"postuninstall\": \"electron-builder install-app-deps\"&#125;,\"main\": \"background.js\",\"devDependencies\": &#123; \"electron\": \"^5.0.6\", \"vue-cli-plugin-electron-builder\": \"^1.3.5\" &#125; src下创建文件backgound.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081'use strict'import &#123; app, protocol, BrowserWindow &#125; from 'electron'import &#123; createProtocol &#125; from 'vue-cli-plugin-electron-builder/lib'import installExtension, &#123; VUEJS_DEVTOOLS &#125; from 'electron-devtools-installer'const isDevelopment = process.env.NODE_ENV !== 'production'// Scheme must be registered before the app is readyprotocol.registerSchemesAsPrivileged([ &#123; scheme: 'app', privileges: &#123; secure: true, standard: true &#125; &#125;])async function createWindow() &#123; // Create the browser window. const win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; // Use pluginOptions.nodeIntegration, leave this alone // See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration for more info nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION, contextIsolation: !process.env.ELECTRON_NODE_INTEGRATION &#125; &#125;) if (process.env.WEBPACK_DEV_SERVER_URL) &#123; // Load the url of the dev server if in development mode await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL) if (!process.env.IS_TEST) win.webContents.openDevTools() &#125; else &#123; createProtocol('app') // Load the index.html when not in development win.loadURL('app://./index.html') &#125;&#125;// Quit when all windows are closed.app.on('window-all-closed', () =&gt; &#123; // On macOS it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== 'darwin') &#123; app.quit() &#125;&#125;)app.on('activate', () =&gt; &#123; // On macOS it's common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (BrowserWindow.getAllWindows().length === 0) createWindow()&#125;)// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on('ready', async () =&gt; &#123; if (isDevelopment &amp;&amp; !process.env.IS_TEST) &#123; // Install Vue Devtools try &#123; // await installExtension(VUEJS_DEVTOOLS) &#125; catch (e) &#123; console.error('Vue Devtools failed to install:', e.toString()) &#125; &#125; createWindow()&#125;)// Exit cleanly on request from parent process in development mode.if (isDevelopment) &#123; if (process.platform === 'win32') &#123; process.on('message', (data) =&gt; &#123; if (data === 'graceful-exit') &#123; app.quit() &#125; &#125;) &#125; else &#123; process.on('SIGTERM', () =&gt; &#123; app.quit() &#125;) &#125;&#125; 先删除之前的node_modules，重新安装依赖即可。 运行自动安装的项目默认会安装 vue devtools 插件，需要科学上网才能安装，否则会自动尝试 5 次，这里我们先把安装命令注释掉即可。 在\\myproject\\src\\background.js中把下面这行注释掉： 启动项目： 1npm run electron:serve 启动成功后会自动弹出窗口： 打包1npm run electron:build 第一次会遇到下面这种情况，依赖下载不下来： 解决办法是手动下载这个文件，然后解压到C:\\Users\\86157\\AppData\\Local\\electron-builder\\Cache\\winCodeSign文件夹下： 再次执行打包命令： 打包成功之后可以在\\myproject\\dist_electron文件夹中看到打包出来的.exe 文件。","tags":[{"name":"electron","slug":"electron","permalink":"http://gecko525.github.io/tags/electron/"},{"name":"vue","slug":"vue","permalink":"http://gecko525.github.io/tags/vue/"}]},{"title":"js浮点数计算精度丢失","date":"2020-04-05T13:32:41.000Z","path":"2020/04/05/js浮点数计算精度丢失/","text":"前言js在计算浮点数时会出现精度误差问题，典型场景是计算金额。 测试实例： 1console.log(0.1+0.2); //0.30000000000000004 对于浮点数的四则运算（加减乘除），几乎所有的编程语言都会出现上面类似的精度误差问题，只是大部分语言都处理封装了避免误差的方法。对于js而言，由于它是一门弱类型的语言，所以并没有对浮点数的运算有解决的封装方法，这能我们自己来解决 精度丢失原理计算机在运算的时候会先将10进制数字转换为二进制，计算完成后再转成10进制。 我们先把0.1和0.2转换为二进制： 1230.1 =&gt; 0.0001 1001 1001 1001..（无限循环）0.2 =&gt; 0.0011 0011 0011 0011…（无限循环） 这里可以看出转换为二进制是一个无限循环的数字，单在计算机中对于无限循环的数字会进行舍入处理的，进行双精度浮点数的小数部分最多支持52位。然后把两个二进制的数进行运算得出的也是一个二进制数值，最后再把它转换为十进制。保留17位小数，所以0.1+0.2的值就成了 0.30000000000000004。 0.1+0.1的值成了0.20000000000000000，全是0的时候可以省略，就成了0.2。 解决方法toFixed方法最简单的处理，通过toFixed方法。 1console.log(parseFloat((0.1+0.2).toFixed(1))); //0.3 toFixed方法可以传入保留小数的位数，只适合所有计算数和结果都保持相同小数位数的运算。 Math.round方法123456Math.formatFloat = function (f, digit) &#123; var m = Math.pow(10, digit); return Math.round(f * m, 10) / m;&#125;var s = 0.1 + 0.2;console.log(Math.formatFloat(s, 1)) // 0.3 整数转换方法原理是先将小数转换成整数，计算完成后再转换成小数。加减乘除都可以，下面以加法为例。 12345678910111213141516function accAdd(arg1, arg2) &#123; var r1, r2, m; try &#123; r1 = arg1.toString().split(\".\")[1].length; &#125; catch(e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(\".\")[1].length; &#125;catch(e)&#123; r2 = 0; &#125; m = Math.pow(10, Math.max(r1, r2)); return (arg1 * m + arg2 * m) / m;&#125;console.log(accAdd(0.1, 0.2)) // 0.3","tags":[{"name":"js","slug":"js","permalink":"http://gecko525.github.io/tags/js/"}]},{"title":"session和jwt鉴权","date":"2020-03-24T03:16:54.000Z","path":"2020/03/24/session和jwt鉴权/","text":"前言由于http是一种无状态协议，即http协议对于交互场景没有记忆能力，因此需要一种方式能让服务器知道是谁在访问，于是传统的cookie-session鉴权和JWT鉴权等方式应运而生。 传统的cookie-session鉴权session 是一种服务器机制，是存储在服务器上的信息。存储方式多种多样，可以是服务器内存中，或者是mongo数据库，redis内存数据库中。而session是基于cookie实现的，服务器会生成sessionID，通过set-cookie的方式写入到客户端的cookie中。客户端每次请求都会自动携带服务器写入sessionID的cookie发送给服务端，通过解析cookie中的sessionID与服务端保存的session来判断用户是否登录。 缺点session通常放在内存中，用户数量如果过大会对服务器产生压力 扩展性。 哪怕session以文件形式保存，放在redis中。对于分布式系统来说会产生高流量的数据读取（文件同步读取问题） JWT鉴权什么是JWT（Json web token）?Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 JWT鉴权的流程 客户端通过post请求请求服务端登录认证接口 服务端用秘密创建JWT 服务端将JWT返回浏览器 客户端在授权报头上发送JWT 服务端检查JWT签名从JWT获取用户信息 服务端向客户端发送响应 优点服务器不需要存储session，节省内存开支 结构简单，占用资源少 JSON格式，可以兼容多种语言 JWT结构分析 JWT由三个部分构成，用英文句点分割(.) 。分为 Header(头信息)。通常包含两部分，type：代表token的类型，这里使用的是JWT类型。 alg:代表使用的算法，例如HMAC SHA256或RSA. 12345// 这会被经过base64Url编码形成第一部分&#123; \"alg\": \"HS256\", \"typ\": \"JWT\"&#125; Payload(载荷信息，实际数据)。一个token的第二部分是荷载信息，它包含一些声明Claim（实体的描述，例：用户信息和其他的一些元数据） 声明分为三类： 标准字段（一套预定义的声明，并不是必须的,这是一套易于使用、操作性强的声明），公共字段，私有字段 标准字段： ​ iss: JWT签发者 ​ sub: JWT所面向的用户 ​ aud: 接收JWT的一方 ​ exp: JWT的过期时间，这个过期时间必须要大于签发时间 ​ nbf: 定义在什么时间之前，该JWT都是不可用的. ​ iat: JWT的签发时间 ​ jti: JWT的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 123456//同样经过Base64Url编码后形成第二部分&#123; \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022&#125; Signature(由头信息+荷载信息+密钥 组合之后进行加密得到) 。使用header中指定的算法将编码后的header、编码后的payload、一个secret进行加密 例如使用的是HMAC SHA256算法，大致流程类似于: 1HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret) 这个signature字段被用来确认JWT信息的发送者是谁，并保证信息没有被修改 JWT校验真伪 服务器收到JWT 将header和payload 用秘钥和对应的算法生成签名 判断生成的签名和jwt的第三部分是否一致 一致则代表可信，不一致则返回错误","tags":[{"name":"javascript","slug":"javascript","permalink":"http://gecko525.github.io/tags/javascript/"}]},{"title":"javascript之宏任务与微任务","date":"2019-10-12T13:45:26.000Z","path":"2019/10/12/javascript之宏任务与微任务/","text":"事件循环JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop 的方案应用而生。 任务队列根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。 宏任务(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。 浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下： (macro)task-&gt;渲染-&gt;(macro)task-&gt;… 宏任务包含：12345678script(整体代码)setTimeoutsetIntervalI/OUI交互事件postMessageMessageChannelsetImmediate(Node.js 环境) 微任务microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。 微任务包含：1234Promise.thenObject.observeMutaionObserverprocess.nextTick(Node.js 环境) 运行机制在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 如图： async/await在async 函数中，遇到 await 会跳出当前函数，并让出线程，再将await后面的代码放到 微任务（microtask）队列中。 看这道面试题： 123456789101112131415161718192021222324async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125; console.log('script start'); setTimeout(function() &#123; console.log('setTimeout');&#125;, 0) async1(); new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 输出顺序为： 12345678script startasync1 startasync2promise1script endasync1 endpromise2setTimeout 执行过程解析： 同步执行, 输出script start 遇到setTimeout，将里面代码放到宏任务队列 继续往下，输出 async1 start，然后执行 async2函数，输出 async2 async2执行完毕，将await async2 后面的代码加入到 微任务队列 继续执行new Promise, 同步输出promise1 遇到 promise.then，加入到微任务队列 然后同步输出 script end 当前宏任务执行完毕，查看微任务队列，按照先进先出原则，依次输出async1 end、promise2 执行下一个宏任务，里面只有一个setTimeout，所以最后输出 setTimeout 同步执行的：script start async1 start async2 promise1 script end微任务队列：async1 end promise2宏任务队列：setTimeout","tags":[{"name":"javascript","slug":"javascript","permalink":"http://gecko525.github.io/tags/javascript/"}]},{"title":"文本溢出显示省略号","date":"2019-04-15T08:27:21.000Z","path":"2019/04/15/文本溢出显示省略号/","text":"文本溢出分为单行溢出和多行溢出，单行溢出一般使用css的text-overflow: ellipsis属性来实现，部分浏览器需要增加width属性；多行溢出可以使用css和js两种方式实现。 单行文本溢出 css代码： 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; /*控制文本不换行（单行）*/ text-overflow属性还可以设置值为字符串，即当文本溢出时显示的内容 多行文本溢出 在WebKit浏览器或移动端（绝大部分是WebKit内核的浏览器）的页面实现比较简单，可以直接使用WebKit的CSS扩展属性(WebKit是私有属性)-webkit-line-clamp ；注意：这是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 css代码： 12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box; /*必须结合的属性 ，将对象作为弹性伸缩盒子模型显示*/-webkit-line-clamp: 2; /*必须结合的属性, 设置文本行数，超出的文本将显示为省略号*/-webkit-box-orient: vertical; /*必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式*/ js解决方案： 可以用js实现，推荐几个成熟的库： Clamp.js 下载及文档地址：https://github.com/josephschmitt/Clamp.js jQuery.dotdotdot 下载及文档地址：https://dotdotdot.frebsite.nl/","tags":[{"name":"css","slug":"css","permalink":"http://gecko525.github.io/tags/css/"}]},{"title":"css设置滚动条样式","date":"2019-01-17T16:00:00.000Z","path":"2019/01/18/css设置滚动条样式/","text":"滚动条可以分为几个部分：滑块、轨道、横竖交界、两端按钮，可通过css修改默认样式 滚动条图解 参数说明1234567::-webkit-scrollbar 滚动条整体部分::-webkit-scrollbar-thumb 滚动条里面的小方块（滑块），能上下或左右移动::-webkit-scrollbar-track 滚动条的轨道（里面装有滑块）::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。::-webkit-scrollbar-track-piece 除去滑块的轨道部分::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件 css样式示例1234567891011121314151617181920212223242526272829/* 可滚动区域 */.scroll &#123; width: 200px; height: 200px; overflow: auto;&#125;/* 滚动条整体 */.scroll::-webkit-scrollbar&#123; width:12px; height:12px;&#125;/* 轨道 */.scroll::-webkit-scrollbar-track&#123; background: #f2f558; border-radius:2px;&#125;/* 滑块 */.scroll::-webkit-scrollbar-thumb&#123; background: #409eff; border-radius:10px;&#125;/* 滑块hover */.scroll::-webkit-scrollbar-thumb:hover&#123; background: #f00;&#125;/* 横竖交界 */.scroll::-webkit-scrollbar-corner&#123; background: #179a16;&#125;","tags":[{"name":"css","slug":"css","permalink":"http://gecko525.github.io/tags/css/"}]},{"title":"vue递归组件","date":"2019-01-04T16:00:00.000Z","path":"2019/01/05/vue递归组件/","text":"现有一嵌套结构数据，嵌套层级未知，问如何将数据中所有的name列出？ 123456789101112[ &#123; name: 'zhangsan', children: [ &#123; name: 'lisi', children: [...] &#125; ] &#125;, ...] 首先想到的肯定是递归，何为递归？ 函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数 第一种思路是先将数据递归取出name，再用v-for遍历渲染。 1234567891011function getName(data) &#123; let names = []; data.forEach((d) =&gt; &#123; names.push(d.name); if (d.children &amp;&amp; d.children.length &gt; 0) &#123; names = names.concat(getName(d.children)); &#125; &#125;); return names;&#125;// ['zhangsan','lisi','wangwu','siliu','qita','sghs','kkig','ssgd'] 这种思路需要自己实现递归函数，并将其存储在一个新的数据中。 第二种是直接利用vue的递归组件实现，即在组件中使用自己 123456789101112131415161718// ShowNames.vue&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in names&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;show-names v-if=&quot;item.children &amp;&amp; item.children.length &gt; 0&quot; :names=&quot;item.children&quot;&gt;&lt;/show-names&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ShowNames&quot;, props: [&quot;names&quot;]&#125;;&lt;/script&gt; 结果如下","tags":[{"name":"vue","slug":"vue","permalink":"http://gecko525.github.io/tags/vue/"}]},{"title":"linux下安装和配置tomcat","date":"2017-12-29T08:31:54.000Z","path":"2017/12/29/linux下安装和配置tomcat/","text":"说明：linux系统为centOs 6.4,tomcat版本为 7.0.81，jdk版本为 7 第一次安装时我用了最新的jdk 9，搞了很长时间都启动不了，最后发现是jdk版本太高。 安装JDK 下载jdk安装包，以jdk-7u80-linux-x64.rpm为例，下载后执行命令： rpm -ivh jdk-7u80-linux-x64.rpm 安装完成后，配置环境变量： vi /etc/profile 在底部添加如下内容： export JAVA_HOME=/usr/java/jdk1.7.0_80 export PATH=$PATH:$JAVA_HOME/bin export JAVA_HOME CLASSPATH PATH wq保存退出 使用以下命令使配置文件生效 source /etc/profile 分别输入命令 java -version 和 javac -version 检测是否安装成功！ 安装tomcat 下载软件包，此处以 apache-tomcat-7.0.81.tar.gz 为例，下载后先建一个文件夹 cd /opt mkdir tomcat 将下载的软件包移动到tomcat文件夹下，并解压 cp /软件包所在路径 /opt/tomcat tar -zxvf apache-tomcat-7.0.81.tar.gz 此时即可启动Tomcat cd /opt/tomcat/apache-tomcat-7.0.81/bin ./startup.sh 在本地浏览器中输入localhost:8080,即可看到默认页面 如果连接失败，首先检查是否8080端口被占用 netstate -anp|grep 8080 如果被占用，则可以杀死占用进程或修改tomcat端口。此处选择后者 cd /opt/tomcat/apache-tomcat-7.0.81/conf vi server.xml 修改以下代码中的8080为8081或其他未被占用的端口,然后重新执行./startup.sh即可 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; \\&gt; &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt; 此时在远程访问一般是不可访问的，还需配置防火墙，可关闭防火墙或开启8080端口，如需访问mysql还可在此处加入3306端口 vi /etc/sysconfig/iptables在-A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT这条命令下添加以下命令： -A INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT -A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT 重启防火墙使配置生效 /etc/init.d/iptables restart停止tomcat进入tomcat的bin目录执行shutdown.sh： cd /opt/tomcat/apache-tomcat-7.0.81/bin ./shutdown.sh","tags":[{"name":"Linux","slug":"Linux","permalink":"http://gecko525.github.io/tags/Linux/"}]},{"title":"windows7下git+openssh搭建远程仓库","date":"2017-12-22T11:53:47.000Z","path":"2017/12/22/windows下git-openssh搭建远程仓库/","text":"1.安装git和openssh2.配置openssh http://blog.51cto.com/leomars/1211702 开启服务：net start opensshd 关闭服务：net stop opensshd 连接测试：ssh Administrator@192.168.28.188 此处会跳转到默认的home&gt;Administrator目录 尝试修改默认home目录失败 3.新建远程仓库 http://blog.csdn.net/ccf0703/article/details/7578276 这个博客讲的挺详细的 用ssh连接后创建或直接在远程仓库所在的机器上创建 此处用ssh mkdir test.git cd test.git git init --bare 退出服务器，远程仓库已建好 4. 克隆远程仓库并测试push和pull在测试机上克隆远程仓库 git clone Administrator@192.168.28.188:test.git 克隆完毕 进入test,创建，提交，推送，默认有一个远程地址叫origin cd test touch a b c git add . git commit -m &quot;创建a b c三个文件&quot; git push origin master 推送完毕，经测试pull也没有问题 有关远程的命令： git remote add origin Administartor@192.168.28.188:test.git git remote set-url origin Administrator@192.168.28.188:test.git git remote rm origin 5.使用密钥连接参照上边第一个博客地址，修改openssh配置文件,然后把要验证的机器的公钥拷贝到.ssh/authorized_keys中，重启服务即可生成密钥指令： ssh-keygen -t rsa -b 2048 6.待解决问题1）home目录未改变，所以远程仓库只能放到home&gt;administrator这个文件夹中","tags":[{"name":"git","slug":"git","permalink":"http://gecko525.github.io/tags/git/"}]},{"title":"浏览器差异及兼容方法","date":"2017-11-15T09:24:51.000Z","path":"2017/11/15/浏览器差异及兼容方法/","text":"目前为止，各大浏览器对HTML标准和JS标准都还未统一。虽然已经有很多框架已经帮我们做好了兼容性处理，但作为一个开发人员，还是非常有必要了解HTML和JS在浏览器中的差异，这能够帮我们更快的解决问题，提高代码质量，编写更优秀，兼容性更好的代码。 HTML和CSS方面的差异 不同浏览器的标签默认的内边距和外边距不同 问题表现：不加样式控制下，默认 margin和padding 差异较大 解决方案：CSS里消除所有标签的默认边距 碰到频率：100% 备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的css文件开头都会先清除各个标签的默认内外边距。 块属性标签float后，又有横行的 margin 情况下，在IE6显示margin比设置的大 问题表现:常见症状是IE6中后面的一块被顶到下一行 碰到频率：90% 解决方案：在float 的标签样式控制中加入 display:inline; 将其转化为行内属性 备注：我们最常用的就是div+css布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用 margin实现，这就是一个必然会碰到的兼容性问题。 设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度 问题表现：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度 碰到频率：60% 解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。 备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。 行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug（类似第二种） 问题表现：IE6里的间距比超过设置的间距 碰到几率：20% 解决方案：在display:block;后面加入 12display:inline;display:table; 备注：行内属性标签，为了设置宽高，我们需要设置 display:block;(除了input标签比较特殊)。在用float布局并有横向的 margin后，在IE6下，他就具有了块属性 float后的横向 margin的bug。不过因为它本身就是行内属性标签，所以我们再加上 display:inline 的话，它的高宽就不可设了。这时候我们还需要在 display:inline后面加入display:talbe。 图片默认有间距 问题表现：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。 碰到几率：20% 解决方案：使用float属性为img布局 备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。 透明度的兼容css设置问题表现:IE这样写:alpha(opacity=50);,Firefox/Chrome这样写: opacity: 0.5; 光标手型 问题表现：Firefox不支持hand，但IE支持pointer 解决方案：统一使用cursor:pointer; JS方面的差异 window.eventFirefox、Chrome 没有 window.event对象,只有event对象,IE里只支持 window.event,而其他主流浏览器两者都支持,所以一般写成： 1function XX(e)&#123;e = e || event;&#125; 获取事件源IE用srcElement获取事件源，而 Firefox用target获取事件源以上两个兼容通常会这么写： 12var e = e||event;var el = e.srcTarget || e.srcElement; 自定义属性问题IE下，可以使用获取常规属性的方法来获取自定义属性如div.value 或 div[value]，也可以使用 getAttribute() 获取自定义属性；Firefox下，只能使用 getAttribute() 获取自定义属性。 innerText、innerHTMLIE支持innerText、innerHTML,Firefox不支持innerText，它支持textContent来实现innerText，不过textContent没有像innerText一样考虑元素的display方式，所以不完全与IE兼容。如果不用textContent，字符串里面不包含HTML代码也可以用innerHTML代替。 可以这样写: 12345if(document.all)&#123; document.getElementById(&apos;element&apos;).innerText = &quot;mytext&quot;; &#125; else&#123; document.getElementById(&apos;element&apos;).textContent = &quot;mytext&quot;; &#125; 窗口的位置IE、Chrome、Firefox：支持使用 12window.screenLeftwindow.screenTop IE8以上、Chrome、safari、Firefox：支持使用 12window.screenXwindow.screenY 兼容代码可以使用下面这段代码： 12var leftX = typeof window.screenLeft == &apos;number&apos; ? window.screenLeft : window.screenX;ver topY = typeof window.screenTop == &apos;number&apos; ? window.screenTop : window.screenY; 6. 窗口的大小Firefox、Chrome、IE9和safari: 12window.innerWidthwindow.innerHeight IE系列: 12document.body.clientWidthdocument.body.clientHeight 不是IE6： 12document.documentElement.clientWidthdocument.documentElement.clientHeight 兼容代码可以这样子写: 1234567891011var width = window.innerWidth;var height = window.innerHeight;if(typeof width != &apos;number&apos;)&#123; if(document.compatMode == &apos;CSS1Compat&apos;)&#123; width = document.documentElement.clientWidth; height = document.docuementElement.clientHeight;&#125;else&#123; width = document.body.clientWidth; height = document.body.clientHeight;&#125; Ajax请求 IE: 1var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) Firefox、Chrome： 1var xhr = new XMLHttpRequest() 访问元素的”class”“class”是JavaScript的一个保留字，在这两个浏览器中我们使用如下句法来访问“class”在IE中这样写： 12var myObject = document.getElementById(&quot;header&quot;); var myAttribute = myObject.getAttribute(&quot;className&quot;); 在Firefox中这样写： 12var myObject = document.getElementById(&quot;header&quot;); var myAttribute = myObject.getAttribute(&quot;class&quot;); 获取鼠标指针的位置 在IE中这样写： 123var myCursorPosition = [0, 0]; myCursorPosition[0] = event.clientX; myCursorPosition[1] = event.clientY; 在Firefox中这样写： 123var myCursorPosition = [0, 0]; myCursorPosition[0] = event.pageX; myCursorPosition[1] = event.pageY;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://gecko525.github.io/tags/javascript/"}]},{"title":"Navigator is deprecated and has been removed from this package.","date":"2017-11-14T16:00:00.000Z","path":"2017/11/15/react-native之navigator/","text":"React-Native 升级到0.44.0版本后，引用了 import { Navigator} from &apos;react-native&apos;; 会报错：Navigator is deprecated and has been removed from this package.通过查阅react-native中文网得知：从0.44版本开始，Navigator被从react native的核心组件库中剥离到了一个名为react-native-deprecated-custom-components的单独模块中。如果你需要继续使用Navigator，则需要先 npm i -S react-native-deprecated-custom-components 然后从这个模块中import，即 import { Navigator } from &apos;react-native-deprecated-custom-components&apos; 然后就可以像以前那样使用Navigator组件了。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://gecko525.github.io/tags/javascript/"}]},{"title":"linux在桌面上创建应用程序快捷方式","date":"2017-10-09T06:15:30.000Z","path":"2017/10/09/linux创建桌面快捷方式/","text":"系统：CentOS 6.4 桌面环境：gnome本文以eclipse为例，使用命令行创建桌面快捷方式 桌面快捷方式文件放置于/usr/share/applications或者~/.local/share/applications处。前一个目录存储的桌面快捷方式每个用户都可以使用，而后一个目录则含有仅仅为特定用户创建的快捷方式。 要为特定程序或命令创建桌面快捷方式，你可以使用任意文本编辑器创建一个.desktop文件，然后把它放到/usr/share/applications或者~/.local/share/applications处。一个典型的.desktop文件如下所示。 1234567891011[Desktop Entry]Encoding=UTF-8Version=1.0 #version Name[en_US]=yEd #name of an app.GenericName=GUI Port Scanner #longer name of an app.Exec=java -jar /opt/yed-3.11.1/yed.jar #command used to launch an app.Terminal=false #whether an app requires to be run in a terminalIcon[en_US]=/opt/yed-3.11.1/icons/yicon32.png #location of icon file.Type=Application #typeCategories=Application;Network;Security; #categories in which this app should be listed.Comment[en_US]=yEd Graph Editor #comment which appears as a tooltip. 1.在/usr/share/applications下创建Eclipse.desktop文件touch /usr/share/applications Eclipse.desktop 2.用任何编辑器编辑Eclipse.desktop文件，写入以下内容12345678910[Desktop Entry]Name=eclipse #快捷方式显示名称Name[zh_CN]=Eclipse #中文名称Comment=eclipse Client #鼠标悬停时说明Exec=/usr/local/eclipse/eclipse #应用程序的绝对路径Icon=/usr/local/eclipse/icon.xpm #应用程序图标的绝对路径Terminal=false #是否用命令行启动Type=Application #类型为程序Categories=Application; #分类Encoding=UTF-8 #编码 写入时要特别注意，后面不能有空格，否则会不识别，出现这种情况： 编辑完，保存后会在/usr/share/applications这个文件夹下出现eclipse的图标此时双击这个图标就可以启动Eclipse了！ 3. 将这个图标拷贝到桌面上cp /usr/share/applications/Eclipse.desktop /home/username/桌面 命令中username换成你自己的名字拷贝完成后可能会出现如下情况：双击后弹出提示：这是由于权限的问题，所以修改权限 chmod 777 /home/username/桌面/Eclipse.desktop 修改后就大功告成了！","tags":[{"name":"Linux","slug":"Linux","permalink":"http://gecko525.github.io/tags/Linux/"}]},{"title":"闭包及其优缺点","date":"2017-06-22T00:59:08.000Z","path":"2017/06/22/闭包及其优缺点/","text":"闭包（closure）是javascript的一大难点，也是它的特色。很多高级应用都要依靠闭包来实现。 1、变量作用域要理解闭包，首先要理解javascript的特殊的变量作用域。 变量的作用域无非就两种：全局变量和局部变量。 javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。 注意点：在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！ 2、如何从外部读取函数内部的局部变量？出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。 那就是在函数内部，再定义一个函数。123456function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 这就是Javascript语言特有的”链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗？ 3、闭包的概念上面代码中的f2函数，就是闭包。 各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够在函数外部读取函数内部变量的一种技术。 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 4、闭包的用途闭包可以用在许多地方。 （1）闭包可以避免添加太多全局变量和全局函数，特别是多人合作开发的时候，可以减少因此产生的命名冲突等，避免污染全局环境。 （2）闭包的另一个特点是可以保存外部函数的变量，内部函数保留了对外部函数的活动变量的引用，所以变量不会被释放。 （3）封装私有变量。我们可以把函数当作一个范围，函数内部的变量就是私有变量，在外部无法引用，但是我们可以通过闭包的特点来访问私有变量。 1234567891011(function() &#123; var name = 'xiaoming'; return &#123; getName: function() &#123; reutrn name; &#125;, setName: function(newName) &#123; name = newName; &#125; &#125;&#125;)() 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 5、使用闭包的注意点（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://gecko525.github.io/tags/javascript/"}]},{"title":"如何实现div填充父容器的剩余宽度空间","date":"2017-05-10T10:45:19.000Z","path":"2017/05/10/如何实现div填充父容器的剩余宽度空间/","text":"前段时间因项目需要，出现了一个有点棘手的问题，那就是如何实现div填充父容器的剩余宽度空间。下面给出一个奇技淫巧： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;固定宽度&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;自动填充宽度&lt;/div&gt; &lt;/div&gt; .box{ width: 500px; height: 250px; border: 2px solid #000; color: #fff; } .left{ width: 200px; height: 200px; background-color: red; float: left;//关键 } .right{ height:200px; background-color: blue; overflow: hidden;//关键 } 即左边盒子左浮float:left，右边盒子设置overflow:hidden;","tags":[{"name":"css","slug":"css","permalink":"http://gecko525.github.io/tags/css/"}]},{"title":"JavaScript之三大家族（offset/scroll/client）","date":"2017-05-04T11:35:57.000Z","path":"2017/05/04/js之三大家族/","text":"三大家族都是以DOM元素节点的属性形式存在的，都是为了获取元素节点更多的信息。 offset家族 只能取值，不能设置值 获取的结果是数值，不是字符 获取的时候不需要style 网页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 网页可见区域宽： document.body.offsetWidth (包括边线的宽); 网页可见区域高： document.body.offsetHeight (包括边线的宽); 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; offsetWidth 和 offsetHeight 获取对象自身的宽度和高度 ，包括内容、边框和内边距，即：offsetWidth = width + border + padding 123div&#123; width: 300px; border-right:2px solid #ccc; padding:10px;&#125; 注意：和 div.style.width 的区别，其只能获取到行内的数值 offsetLeft 和 offsetTop 距离第一个有定位的父级盒子左边和上边的距离 父级盒子必须要有定位，如果没有，则最终以body为准！ offsetLeft 从父亲的padding开始算 父亲的border不算.即：从子盒子边框到定位父盒子边框的距离。 scroll家族基本概念 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 在实际开发中使用比较多的就是scrollTop，如下图： 处理scroll家族浏览器适配问题 ie9+ 和 最新浏览器 window.pageXOffset; （scrollLeft） window.pageYOffset; （scrollTop） Firefox浏览器 和 其他浏览器 document.documentElement.scrollTop; Chrome浏览器 和 没有声明 DTD document.body.scrollTop; 兼容写法 var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; scrollTo(x,y) 把内容滚动到指定的坐标 格式：scrollTo(xpos,ypos) xpos 必需；要在窗口文档显示区左上角显示的文档的 x 坐标； ypos 必需；要在窗口文档显示区左上角显示的文档的 y 坐标 。 网页大部分都没有水平滚动条，所以，这个x 不太常用。 client家族###1.1 clientWidth和clientHeight 网页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 1.2 clientLeft和clientTop clientLeft，clientTop 返回的是元素边框的borderWidth， 如果不指定一个边框或者不定位改元素，其值就为0 1.3 offset、client和scroll的区别分析 left和top分析： clientLeft: 左边边框的宽度；clientTop: 上边边框的宽度 offsetLeft: 当前元素距离有定位的父盒子左边的距离；offsetTop: 当前元素距离有定位的父盒子上边的距离 scrollLeft: 左边滚动的长度; scrollTop: 上边滚动的长度; width和height分析 clientWidth\\/Height: 内容 + 内边距 offsetWidth\\/Height: 内容 + 内边距 + 边框 scrollWidth\\/Height: 滚动内容的宽度和高度","tags":[{"name":"javascript","slug":"javascript","permalink":"http://gecko525.github.io/tags/javascript/"}]},{"title":"你好，博客！","date":"2017-04-12T14:37:17.000Z","path":"2017/04/12/你好，博客！/","text":"第一个博客 这是我的第一个博客，以后要及时更新，哈哈哈！ 不积跬步,无以至千里;不积小流,无以成江海","tags":[]}]