[{"title":"windows下git+openssh搭建远程仓库","slug":"windows下git-openssh搭建远程仓库","date":"2017-12-22T11:53:47.000Z","updated":"2017-12-22T12:32:32.405Z","comments":true,"path":"2017/12/22/windows下git-openssh搭建远程仓库/","link":"","permalink":"http://yoursite.com/2017/12/22/windows下git-openssh搭建远程仓库/","excerpt":"1.安装git和openssh2.配置openssh http://blog.51cto.com/leomars/1211702 开启服务：net start opensshd 关闭服务：net stop opensshd 连接测试：ssh Administrator@192.168.28.188 此处会跳转到默认的home&gt;Administrator目录 尝试修改默认home目录失败","text":"1.安装git和openssh2.配置openssh http://blog.51cto.com/leomars/1211702 开启服务：net start opensshd 关闭服务：net stop opensshd 连接测试：ssh Administrator@192.168.28.188 此处会跳转到默认的home&gt;Administrator目录 尝试修改默认home目录失败 3.新建远程仓库 http://blog.csdn.net/ccf0703/article/details/7578276 这个博客讲的挺详细的 用ssh连接后创建或直接在远程仓库所在的机器上创建 此处用ssh mkdir test.git cd test.git git init --bare 退出服务器，远程仓库已建好 4. 克隆远程仓库并测试push和pull在测试机上克隆远程仓库 git clone Administrator@192.168.28.188:test.git 克隆完毕 进入test,创建，提交，推送，默认有一个远程地址叫origin cd test touch a b c git add . git commit -m &quot;创建a b c三个文件&quot; git push origin master 推送完毕，经测试pull也没有问题 有关远程的命令： git remote add origin Administartor@192.168.28.188:test.git git remote set-url origin Administrator@192.168.28.188:test.git git remote rm origin 5.待解决问题1）home目录未改变，所以远程仓库只能放到home&gt;administrator这个文件夹中 2）只能使用密码登录，公钥没有试验成功（可参考上边提到的第一篇博客）","categories":[],"tags":[]},{"title":"linux在桌面上创建应用程序快捷方式","slug":"linux创建桌面快捷方式","date":"2017-10-09T06:15:30.000Z","updated":"2017-12-22T12:33:06.688Z","comments":true,"path":"2017/10/09/linux创建桌面快捷方式/","link":"","permalink":"http://yoursite.com/2017/10/09/linux创建桌面快捷方式/","excerpt":"系统：CentOS 6.4 桌面环境：gnome本文以eclipse为例，使用命令行创建桌面快捷方式 桌面快捷方式文件放置于/usr/share/applications或者~/.local/share/applications处。前一个目录存储的桌面快捷方式每个用户都可以使用，而后一个目录则含有仅仅为特定用户创建的快捷方式。 要为特定程序或命令创建桌面快捷方式，你可以使用任意文本编辑器创建一个.desktop文件，然后把它放到/usr/share/applications或者~/.local/share/applications处。一个典型的.desktop文件如下所示。","text":"系统：CentOS 6.4 桌面环境：gnome本文以eclipse为例，使用命令行创建桌面快捷方式 桌面快捷方式文件放置于/usr/share/applications或者~/.local/share/applications处。前一个目录存储的桌面快捷方式每个用户都可以使用，而后一个目录则含有仅仅为特定用户创建的快捷方式。 要为特定程序或命令创建桌面快捷方式，你可以使用任意文本编辑器创建一个.desktop文件，然后把它放到/usr/share/applications或者~/.local/share/applications处。一个典型的.desktop文件如下所示。 1234567891011[Desktop Entry]Encoding=UTF-8Version=1.0 #version Name[en_US]=yEd #name of an app.GenericName=GUI Port Scanner #longer name of an app.Exec=java -jar /opt/yed-3.11.1/yed.jar #command used to launch an app.Terminal=false #whether an app requires to be run in a terminalIcon[en_US]=/opt/yed-3.11.1/icons/yicon32.png #location of icon file.Type=Application #typeCategories=Application;Network;Security; #categories in which this app should be listed.Comment[en_US]=yEd Graph Editor #comment which appears as a tooltip. 1.在/usr/share/applications下创建Eclipse.desktop文件touch /usr/share/applications Eclipse.desktop 2.用任何编辑器编辑Eclipse.desktop文件，写入以下内容12345678910[Desktop Entry]Name=eclipse #快捷方式显示名称Name[zh_CN]=Eclipse #中文名称Comment=eclipse Client #鼠标悬停时说明Exec=/usr/local/eclipse/eclipse #应用程序的绝对路径Icon=/usr/local/eclipse/icon.xpm #应用程序图标的绝对路径Terminal=false #是否用命令行启动Type=Application #类型为程序Categories=Application; #分类Encoding=UTF-8 #编码 写入时要特别注意，后面不能有空格，否则会不识别，出现这种情况： 编辑完，保存后会在/usr/share/applications这个文件夹下出现eclipse的图标此时双击这个图标就可以启动Eclipse了！ 3. 将这个图标拷贝到桌面上cp /usr/share/applications/Eclipse.desktop /home/username/桌面 命令中username换成你自己的名字拷贝完成后可能会出现如下情况：双击后弹出提示：这是由于权限的问题，所以修改权限 chmod 777 /home/username/桌面/Eclipse.desktop 修改后就大功告成了！","categories":[],"tags":[]},{"title":"linux下安装和配置tomcat","slug":"linux下安装和配置tomcat","date":"2017-09-29T08:31:54.000Z","updated":"2017-12-22T12:33:43.853Z","comments":true,"path":"2017/09/29/linux下安装和配置tomcat/","link":"","permalink":"http://yoursite.com/2017/09/29/linux下安装和配置tomcat/","excerpt":"说明：linux系统为centOs 6.4,tomcat版本为 7.0.81，jdk版本为 7 第一次安装时我用了最新的jdk 9，搞了很长时间都启动不了，最后发现是jdk版本太高。 安装JDK 下载jdk安装包，以jdk-7u80-linux-x64.rpm为例，下载后执行命令： rpm -ivh jdk-7u80-linux-x64.rpm 安装完成后，配置环境变量： vi /etc/profile","text":"说明：linux系统为centOs 6.4,tomcat版本为 7.0.81，jdk版本为 7 第一次安装时我用了最新的jdk 9，搞了很长时间都启动不了，最后发现是jdk版本太高。 安装JDK 下载jdk安装包，以jdk-7u80-linux-x64.rpm为例，下载后执行命令： rpm -ivh jdk-7u80-linux-x64.rpm 安装完成后，配置环境变量： vi /etc/profile 在底部添加如下内容： export JAVA_HOME=/usr/java/jdk1.7.0_80 export PATH=$PATH:$JAVA_HOME/bin export JAVA_HOME CLASSPATH PATH wq保存退出 使用以下命令使配置文件生效 source /etc/profile 分别输入命令 java -version 和 javac -version 检测是否安装成功！ 安装tomcat 下载软件包，此处以 apache-tomcat-7.0.81.tar.gz 为例，下载后先建一个文件夹 cd /opt mkdir tomcat 将下载的软件包移动到tomcat文件夹下，并解压 cp /软件包所在路径 /opt/tomcat tar -zxvf apache-tomcat-7.0.81.tar.gz 此时即可启动Tomcat cd /opt/tomcat/apache-tomcat-7.0.81/bin ./startup.sh 在本地浏览器中输入localhost:8080,即可看到默认页面 如果连接失败，首先检查是否8080端口被占用 netstate -anp|grep 8080 如果被占用，则可以杀死占用进程或修改tomcat端口。此处选择后者 cd /opt/tomcat/apache-tomcat-7.0.81/conf vi server.xml 修改以下代码中的8080为8081或其他未被占用的端口,然后重新执行./startup.sh即可 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; \\&gt; &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt; 此时在远程访问一般是不可访问的，还需配置防火墙，可关闭防火墙或开启8080端口，如需访问mysql还可在此处加入3306端口 vi /etc/sysconfig/iptables在-A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT这条命令下添加以下命令： -A INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT -A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT 重启防火墙使配置生效 /etc/init.d/iptables restart停止tomcat进入tomcat的bin目录执行shutdown.sh： cd /opt/tomcat/apache-tomcat-7.0.81/bin ./shutdown.sh","categories":[],"tags":[]},{"title":"javascript解决for循环中i取值的问题","slug":"javascript解决for循环中i取值的问题","date":"2017-08-13T16:00:00.000Z","updated":"2017-09-29T10:25:36.262Z","comments":true,"path":"2017/08/14/javascript解决for循环中i取值的问题/","link":"","permalink":"http://yoursite.com/2017/08/14/javascript解决for循环中i取值的问题/","excerpt":"","text":"http://www.mamicode.com/info-detail-1212276.html","categories":[],"tags":[]},{"title":"传统及angular上传文件","slug":"传统及angular上传文件","date":"2017-07-20T16:00:00.000Z","updated":"2017-09-29T10:23:10.640Z","comments":true,"path":"2017/07/21/传统及angular上传文件/","link":"","permalink":"http://yoursite.com/2017/07/21/传统及angular上传文件/","excerpt":"","text":"最近做了个上传文件的功能 1.传统方式 1234&lt;form action=&quot;php/upfile.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; id=&quot;uploadform&quot;&gt;&lt;input type=&quot;file&quot; name=&quot;image&quot; file-model=&quot;images&quot; onchange=&quot;angular.element(this).scope().img_upload(this.files)&quot;/&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 2.angular上传 12345&lt;form enctype=&quot;multipart/form-data&quot; id=&quot;uploadform&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot; file-model=&quot;images&quot; onchange=&quot;angular.element(this).scope().img_upload(this.files)&quot;/&gt; &lt;button ng-click=&quot;save()&quot;&gt;保存&lt;/button&gt;&lt;/form&gt; 后台用PHP 12345678910111213141516171819202122232425262728&lt;?php// 休息5秒sleep(5);// 输出上传的生成的信息print_r($_FILES);//格式如下/*Array ( [upFile] =&gt; Array ( [name] =&gt; 1.jpg [type] =&gt; image/jpeg [tmp_name] =&gt; D:\\wamp\\tmp\\phpF928.tmp [error] =&gt; 0 [size] =&gt; 109994 ) )*//*可以同时接收多个上传的文件, 每多一个文件数组元素就会增加一个*/// 1.获取上传文件对应的字典$dic = $_FILES[&quot;image&quot;];// 2.获取上传文件的名称$fileName = $dic[&quot;name&quot;];//echo $fileName;// 3.获取上传文件存储的临时路径$filePath = $dic[&quot;tmp_name&quot;];//echo $filePath;// 3.将上传的文件移动到指定文件夹下move_uploaded_file($filePath, &quot;images/&quot;.$fileName);","categories":[],"tags":[]},{"title":"Navigator is deprecated and has been removed from this package.","slug":"react-native之navigator","date":"2017-05-08T16:00:00.000Z","updated":"2017-05-09T10:27:00.801Z","comments":true,"path":"2017/05/09/react-native之navigator/","link":"","permalink":"http://yoursite.com/2017/05/09/react-native之navigator/","excerpt":"React-Native 升级到0.44.0版本后，引用了 import { Navigator} from &apos;react-native&apos;; 会报错：Navigator is deprecated and has been removed from this package.","text":"React-Native 升级到0.44.0版本后，引用了 import { Navigator} from &apos;react-native&apos;; 会报错：Navigator is deprecated and has been removed from this package.通过查阅react-native中文网得知：从0.44版本开始，Navigator被从react native的核心组件库中剥离到了一个名为react-native-deprecated-custom-components的单独模块中。如果你需要继续使用Navigator，则需要先 npm i -S react-native-deprecated-custom-components 然后从这个模块中import，即 import { Navigator } from &apos;react-native-deprecated-custom-components&apos; 然后就可以像以前那样使用Navigator组件了。","categories":[],"tags":[]},{"title":"浏览器差异及兼容方法","slug":"浏览器差异及兼容方法","date":"2016-06-20T09:24:51.000Z","updated":"2017-05-18T13:27:08.729Z","comments":true,"path":"2016/06/20/浏览器差异及兼容方法/","link":"","permalink":"http://yoursite.com/2016/06/20/浏览器差异及兼容方法/","excerpt":"目前为止，各大浏览器对HTML标准和JS标准都还未统一。虽然已经有很多框架已经帮我们做好了兼容性处理，但作为一个开发人员，还是非常有必要了解HTML和JS在浏览器中的差异，这能够帮我们更快的解决问题，提高代码质量，编写更优秀，兼容性更好的代码。","text":"目前为止，各大浏览器对HTML标准和JS标准都还未统一。虽然已经有很多框架已经帮我们做好了兼容性处理，但作为一个开发人员，还是非常有必要了解HTML和JS在浏览器中的差异，这能够帮我们更快的解决问题，提高代码质量，编写更优秀，兼容性更好的代码。 HTML和CSS方面的差异 不同浏览器的标签默认的内边距和外边距不同问题表现：不加样式控制下，默认 margin和padding 差异较大解决方案：CSS里消除所有标签的默认边距碰到频率：100%备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的css文件开头都会先清除各个标签的默认内外边距。 块属性标签float后，又有横行的 margin 情况下，在IE6显示margin比设置的大问题表现:常见症状是IE6中后面的一块被顶到下一行碰到频率：90%解决方案：在float 的标签样式控制中加入 display:inline; 将其转化为行内属性备注：我们最常用的就是div+css布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用 margin实现，这就是一个必然会碰到的兼容性问题。 设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度问题表现：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度碰到频率：60%解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。 行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug（类似第二种）问题表现：IE6里的间距比超过设置的间距碰到几率：20%解决方案：在display:block;后面加入 12display:inline;display:table; 备注：行内属性标签，为了设置宽高，我们需要设置 display:block;(除了input标签比较特殊)。在用float布局并有横向的 margin后，在IE6下，他就具有了块属性 float后的横向 margin的bug。不过因为它本身就是行内属性标签，所以我们再加上 display:inline 的话，它的高宽就不可设了。这时候我们还需要在 display:inline后面加入display:talbe。 图片默认有间距问题表现：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。碰到几率：20%解决方案：使用float属性为img布局备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。 透明度的兼容css设置问题表现:IE这样写:alpha(opacity=50);,Firefox/Chrome这样写: opacity: 0.5; 光标手型问题表现：Firefox不支持hand，但IE支持pointer解决方案：统一使用cursor:pointer; JS方面的差异 window.eventFirefox、Chrome 没有 window.event对象,只有event对象,IE里只支持 window.event,而其他主流浏览器两者都支持,所以一般写成： 1function XX(e)&#123;e = e || event;&#125; 获取事件源IE用srcElement获取事件源，而 Firefox用target获取事件源以上两个兼容通常会这么写： 12var e = e||event;var el = e.srcTarget || e.srcElement; 自定义属性问题IE下，可以使用获取常规属性的方法来获取自定义属性如div.value 或 div[value]，也可以使用 getAttribute() 获取自定义属性；Firefox下，只能使用 getAttribute() 获取自定义属性。 innerText、innerHTMLIE支持innerText、innerHTML,Firefox不支持innerText，它支持textContent来实现innerText，不过textContent没有像innerText一样考虑元素的display方式，所以不完全与IE兼容。如果不用textContent，字符串里面不包含HTML代码也可以用innerHTML代替。 可以这样写: 12345if(document.all)&#123; document.getElementById(&apos;element&apos;).innerText = &quot;mytext&quot;; &#125; else&#123; document.getElementById(&apos;element&apos;).textContent = &quot;mytext&quot;; &#125; 窗口的位置IE、Chrome、Firefox：支持使用 12window.screenLeftwindow.screenTop IE8以上、Chrome、safari、Firefox：支持使用 12window.screenXwindow.screenY 兼容代码可以使用下面这段代码： 12var leftX = typeof window.screenLeft == &apos;number&apos; ? window.screenLeft : window.screenX;ver topY = typeof window.screenTop == &apos;number&apos; ? window.screenTop : window.screenY; 6. 窗口的大小Firefox、Chrome、IE9和safari: 12window.innerWidthwindow.innerHeight IE系列: 12document.body.clientWidthdocument.body.clientHeight 不是IE6： 12document.documentElement.clientWidthdocument.documentElement.clientHeight 兼容代码可以这样子写: 1234567891011var width = window.innerWidth;var height = window.innerHeight;if(typeof width != &apos;number&apos;)&#123; if(document.compatMode == &apos;CSS1Compat&apos;)&#123; width = document.documentElement.clientWidth; height = document.docuementElement.clientHeight;&#125;else&#123; width = document.body.clientWidth; height = document.body.clientHeight;&#125; Ajax请求 IE: 1var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) Firefox、Chrome： 1var xhr = new XMLHttpRequest() 访问元素的”class”“class”是JavaScript的一个保留字，在这两个浏览器中我们使用如下句法来访问“class”在IE中这样写： 12var myObject = document.getElementById(&quot;header&quot;); var myAttribute = myObject.getAttribute(&quot;className&quot;); 在Firefox中这样写： 12var myObject = document.getElementById(&quot;header&quot;); var myAttribute = myObject.getAttribute(&quot;class&quot;); 获取鼠标指针的位置 在IE中这样写： 123var myCursorPosition = [0, 0]; myCursorPosition[0] = event.clientX; myCursorPosition[1] = event.clientY; 在Firefox中这样写： 123var myCursorPosition = [0, 0]; myCursorPosition[0] = event.pageX; myCursorPosition[1] = event.pageY;","categories":[],"tags":[]},{"title":"闭包及其优缺点","slug":"闭包","date":"2016-06-02T00:59:08.000Z","updated":"2017-06-02T01:14:46.517Z","comments":true,"path":"2016/06/02/闭包/","link":"","permalink":"http://yoursite.com/2016/06/02/闭包/","excerpt":"闭包（closure）是javascript的一大难点，也是它的特色。很多高级应用都要依靠闭包来实现。","text":"闭包（closure）是javascript的一大难点，也是它的特色。很多高级应用都要依靠闭包来实现。 1、变量作用域要理解闭包，首先要理解javascript的特殊的变量作用域。 变量的作用域无非就两种：全局变量和局部变量。 javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。 注意点：在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！ 2、如何从外部读取函数内部的局部变量？出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。 那就是在函数内部，再定义一个函数。123456function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 这就是Javascript语言特有的”链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 3、闭包的概念上面代码中的f2函数，就是闭包。 各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 4、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 5、使用闭包的注意点（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。","categories":[],"tags":[]},{"title":"如何实现div填充父容器的剩余宽度空间","slug":"如何实现div填充父容器的剩余宽度空间","date":"2016-04-10T10:45:19.000Z","updated":"2017-05-17T11:04:45.295Z","comments":true,"path":"2016/04/10/如何实现div填充父容器的剩余宽度空间/","link":"","permalink":"http://yoursite.com/2016/04/10/如何实现div填充父容器的剩余宽度空间/","excerpt":"前段时间因项目需要，出现了一个有点棘手的问题，那就是如何实现div填充父容器的剩余宽度空间。","text":"前段时间因项目需要，出现了一个有点棘手的问题，那就是如何实现div填充父容器的剩余宽度空间。下面给出一个奇技淫巧： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;固定宽度&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;自动填充宽度&lt;/div&gt; &lt;/div&gt; .box{ width: 500px; height: 250px; border: 2px solid #000; color: #fff; } .left{ width: 200px; height: 200px; background-color: red; float: left;//关键 } .right{ height:200px; background-color: blue; overflow: hidden;//关键 } 即左边盒子左浮float:left，右边盒子设置overflow:hidden;","categories":[],"tags":[]},{"title":"JavaScript之三大家族（offset/scroll/client）","slug":"js之三大家族","date":"2015-06-01T11:35:57.000Z","updated":"2017-05-09T03:16:25.934Z","comments":true,"path":"2015/06/01/js之三大家族/","link":"","permalink":"http://yoursite.com/2015/06/01/js之三大家族/","excerpt":"三大家族都是以DOM元素节点的属性形式存在的，都是为了获取元素节点更多的信息。 offset家族 只能取值，不能设置值 获取的结果是数值，不是字符 获取的时候不需要style","text":"三大家族都是以DOM元素节点的属性形式存在的，都是为了获取元素节点更多的信息。 offset家族 只能取值，不能设置值 获取的结果是数值，不是字符 获取的时候不需要style 网页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 网页可见区域宽： document.body.offsetWidth (包括边线的宽); 网页可见区域高： document.body.offsetHeight (包括边线的宽); 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; offsetWidth 和 offsetHeight 获取对象自身的宽度和高度 ，包括内容、边框和内边距，即：offsetWidth = width + border + padding 123div&#123; width: 300px; border-right:2px solid #ccc; padding:10px;&#125; 注意：和 div.style.width 的区别，其只能获取到行内的数值 offsetLeft 和 offsetTop 距离第一个有定位的父级盒子左边和上边的距离 父级盒子必须要有定位，如果没有，则最终以body为准！ offsetLeft 从父亲的padding开始算 父亲的border不算.即：从子盒子边框到定位父盒子边框的距离。 scroll家族基本概念 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 在实际开发中使用比较多的就是scrollTop，如下图： 处理scroll家族浏览器适配问题 ie9+ 和 最新浏览器 window.pageXOffset; （scrollLeft） window.pageYOffset; （scrollTop） Firefox浏览器 和 其他浏览器 document.documentElement.scrollTop; Chrome浏览器 和 没有声明 DTD document.body.scrollTop; 兼容写法 var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; scrollTo(x,y) 把内容滚动到指定的坐标 格式：scrollTo(xpos,ypos) xpos 必需；要在窗口文档显示区左上角显示的文档的 x 坐标； ypos 必需；要在窗口文档显示区左上角显示的文档的 y 坐标 。 网页大部分都没有水平滚动条，所以，这个x 不太常用。 client家族###1.1 clientWidth和clientHeight 网页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 1.2 clientLeft和clientTop clientLeft，clientTop 返回的是元素边框的borderWidth， 如果不指定一个边框或者不定位改元素，其值就为0 1.3 offset、client和scroll的区别分析 left和top分析： clientLeft: 左边边框的宽度；clientTop: 上边边框的宽度 offsetLeft: 当前元素距离有定位的父盒子左边的距离；offsetTop: 当前元素距离有定位的父盒子上边的距离 scrollLeft: 左边滚动的长度; scrollTop: 上边滚动的长度; width和height分析 clientWidth\\/Height: 内容 + 内边距 offsetWidth\\/Height: 内容 + 内边距 + 边框 scrollWidth\\/Height: 滚动内容的宽度和高度","categories":[],"tags":[]},{"title":"你好，博客！","slug":"你好，博客！","date":"2015-03-12T14:37:17.000Z","updated":"2017-05-09T03:06:19.213Z","comments":true,"path":"2015/03/12/你好，博客！/","link":"","permalink":"http://yoursite.com/2015/03/12/你好，博客！/","excerpt":"","text":"第一个博客这是我的第一个博客，以后要及时更新，哈哈哈！ 不积跬步,无以至千里;不积小流,无以成江海","categories":[],"tags":[]}]